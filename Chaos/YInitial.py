# Importing all the function from Xn module
from Xn import *

# This module helps in calculating the value of y0 using the first logistic map function Xn
# The Y0 value obtained here will be used in the second logistic map Yn
# Y0 value is obtained after we sum Y01 and Y02, and mod it with 1


# This function takes the list of 10 binary keys and 3 key index values
# The 3 given keys are then concatenated to create a 24 bit log binary string B2
# This function returns the value of y01
def y01(binary_keys,i=0,j=1,k=2):
    keys = binary_keys
    B2 = keys[i] + keys[j] + keys[k]
    y01 = (int(''.join(B2),2)) / (2**24)
    return y01


# This function takes the list of 10 binary keys, 24 integer values obtained using first logistic map (Xn) and 3 key index values
# The 3 given keys are then concatenated to create a 24 bit log binary string B2
# This function returns the value of y02
def y02(binary_keys,_24_values_of_Pk,i=0,j=1,k=2):
    p24 = _24_values_of_Pk
    keys = binary_keys
    B2 = keys[i] + keys[j] + keys[k]
    y02=0

    for i in range(0,len(p24)):
        y02 = (int(B2[p24[i]]))*(2**i) + y02


    y02 = y02/(2**24)
    return y02

# This function mods the value generated by y01() and y02() function by 1
def y0(y01,y02):
    return (y01+y02)%1


## Test code
#############################################################################
## Using the Key module we generate the 10 8-bit keys and 20 hexadecimal keys from key given by the user
## and use them in y01() and y02() function to generate y0 value which lies between 0 and 1


# binary_keys = to_8bit_keys('ankit12345')
# hex_keys = to_hex_keys('ankit12345')
#
# x0 = x0(x01(binary_keys),x02(hex_keys))
#
# f24 = xn(x0)
#
# p24 = pk(f24)
#
# y0 = y0(y01(binary_keys),y02(binary_keys,p24))
#
# print(y0)
